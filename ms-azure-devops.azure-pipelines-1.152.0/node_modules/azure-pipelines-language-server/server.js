/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Adam Voss. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const request_light_1 = require("request-light");
const path = require("path");
const fs = require("fs");
const vscode_uri_1 = require("vscode-uri");
const URL = require("url");
const nls = require("vscode-nls");
const Strings = require("azure-pipelines-language-service");
const azure_pipelines_language_service_1 = require("azure-pipelines-language-service");
const azure_pipelines_language_service_2 = require("azure-pipelines-language-service");
const azure_pipelines_language_service_3 = require("azure-pipelines-language-service");
const azure_pipelines_language_service_4 = require("azure-pipelines-language-service");
const azure_pipelines_language_service_5 = require("azure-pipelines-language-service");
nls.config(process.env['VSCODE_NLS_CONFIG']);
var SchemaAssociationNotification;
(function (SchemaAssociationNotification) {
    SchemaAssociationNotification.type = new vscode_languageserver_1.NotificationType('json/schemaAssociations');
})(SchemaAssociationNotification || (SchemaAssociationNotification = {}));
var VSCodeContentRequest;
(function (VSCodeContentRequest) {
    VSCodeContentRequest.type = new vscode_languageserver_1.RequestType('vscode/content');
})(VSCodeContentRequest || (VSCodeContentRequest = {}));
var CustomSchemaContentRequest;
(function (CustomSchemaContentRequest) {
    CustomSchemaContentRequest.type = new vscode_languageserver_1.RequestType('custom/schema/content');
})(CustomSchemaContentRequest || (CustomSchemaContentRequest = {}));
var CustomSchemaRequest;
(function (CustomSchemaRequest) {
    CustomSchemaRequest.type = new vscode_languageserver_1.RequestType('custom/schema/request');
})(CustomSchemaRequest || (CustomSchemaRequest = {}));
var ColorSymbolRequest;
(function (ColorSymbolRequest) {
    ColorSymbolRequest.type = new vscode_languageserver_1.RequestType('json/colorSymbols');
})(ColorSymbolRequest || (ColorSymbolRequest = {}));
// Create a connection for the server.
let connection = null;
if (process.argv.indexOf('--stdio') == -1) {
    connection = vscode_languageserver_1.createConnection(vscode_languageserver_1.ProposedFeatures.all);
}
else {
    connection = vscode_languageserver_1.createConnection();
}
console.log = connection.console.log.bind(connection.console);
console.error = connection.console.error.bind(connection.console);
// Create a simple text document manager. The text document manager
// supports full document sync only
let documents = new vscode_languageserver_1.TextDocuments();
// Make the text document manager listen on the connection
// for open, change and close text document events
documents.listen(connection);
let clientDynamicRegisterSupport = false;
let hasWorkspaceFolderCapability = false;
// After the server has started the client sends an initilize request. The server receives
// in the passed params the rootPath of the workspace plus the client capabilities.
let capabilities;
let workspaceFolders = [];
let workspaceRoot;
connection.onInitialize((params) => {
    capabilities = params.capabilities;
    workspaceFolders = params["workspaceFolders"];
    workspaceRoot = vscode_uri_1.default.parse(params.rootPath);
    function hasClientCapability(...keys) {
        let c = params.capabilities;
        for (let i = 0; c && i < keys.length; i++) {
            c = c[keys[i]];
        }
        return !!c;
    }
    hasWorkspaceFolderCapability = capabilities.workspace && !!capabilities.workspace.workspaceFolders;
    clientDynamicRegisterSupport = hasClientCapability('textDocument', 'formatting', 'dynamicRegistration');
    return {
        capabilities: {
            textDocumentSync: documents.syncKind,
            completionProvider: { resolveProvider: true },
            hoverProvider: true,
            documentSymbolProvider: true,
            documentFormattingProvider: false
        }
    };
});
let workspaceContext = {
    resolveRelativePath: (relativePath, resource) => {
        return URL.resolve(resource, relativePath);
    }
};
let schemaRequestService = (uri) => {
    //For the case when we are multi root and specify a workspace location
    if (hasWorkspaceFolderCapability) {
        for (let folder in workspaceFolders) {
            let currFolder = workspaceFolders[folder];
            let currFolderUri = currFolder["uri"];
            let currFolderName = currFolder["name"];
            let isUriRegex = new RegExp('^(?:[a-z]+:)?//', 'i');
            if (uri.indexOf(currFolderName) !== -1 && !uri.match(isUriRegex)) {
                let beforeFolderName = currFolderUri.split(currFolderName)[0];
                let uriSplit = uri.split(currFolderName);
                uriSplit.shift();
                let afterFolderName = uriSplit.join(currFolderName);
                uri = beforeFolderName + currFolderName + afterFolderName;
            }
        }
    }
    if (Strings.startsWith(uri, 'file://')) {
        let fsPath = vscode_uri_1.default.parse(uri).fsPath;
        return new Promise((c, e) => {
            fs.readFile(fsPath, 'UTF-8', (err, result) => {
                err ? e('') : c(azure_pipelines_language_service_5.ParseSchema(result.toString()));
            });
        });
    }
    else if (Strings.startsWith(uri, 'vscode://')) {
        return connection.sendRequest(VSCodeContentRequest.type, uri).then(responseText => {
            return responseText;
        }, error => {
            return error.message;
        });
    }
    else {
        let scheme = vscode_uri_1.default.parse(uri).scheme.toLowerCase();
        if (scheme !== 'http' && scheme !== 'https') {
            // custom scheme
            return connection.sendRequest(CustomSchemaContentRequest.type, uri).then((content) => azure_pipelines_language_service_5.ParseSchema(content));
        }
    }
    if (uri.indexOf('//schema.management.azure.com/') !== -1) {
        connection.telemetry.logEvent({
            key: 'json.schema',
            value: {
                schemaURL: uri
            }
        });
    }
    let headers = { 'Accept-Encoding': 'gzip, deflate' };
    return request_light_1.xhr({ url: uri, followRedirects: 5, headers }).then(response => {
        return azure_pipelines_language_service_5.ParseSchema(response.responseText);
    }, (error) => {
        return Promise.reject(error.responseText || request_light_1.getErrorStatusDescription(error.status) || error.toString());
    });
};
exports.KUBERNETES_SCHEMA_URL = "https://gist.githubusercontent.com/JPinkney/ccaf3909ef811e5657ca2e2e1fa05d76/raw/f85e51bfb67fdb99ab7653c2953b60087cc871ea/openshift_schema_all.json";
exports.KEDGE_SCHEMA_URL = "https://raw.githubusercontent.com/kedgeproject/json-schema/master/master/kedge-json-schema.json";
exports.customLanguageService = azure_pipelines_language_service_2.getLanguageService(schemaRequestService, [], //contributions
(resource) => connection.sendRequest(CustomSchemaRequest.type, resource), workspaceContext);
let yamlConfigurationSettings = void 0;
let schemaAssociations = void 0;
let formatterRegistration = null;
let specificValidatorPaths = [];
let schemaConfigurationSettings = [];
let schemaStoreSettings = [];
let customTags = [];
connection.onDidChangeConfiguration((change) => {
    var settings = change.settings;
    request_light_1.configure(settings.http && settings.http.proxy, settings.http && settings.http.proxyStrictSSL);
    specificValidatorPaths = [];
    yamlConfigurationSettings = settings.yaml && settings.yaml.schemas;
    schemaConfigurationSettings = [];
    customTags = settings.yaml && settings.yaml.customTags ? settings.yaml.customTags : [];
    for (let url in yamlConfigurationSettings) {
        let globPattern = yamlConfigurationSettings[url];
        let schemaObj = {
            "fileMatch": Array.isArray(globPattern) ? globPattern : [globPattern],
            "url": url
        };
        schemaConfigurationSettings.push(schemaObj);
    }
    updateConfiguration();
    // dynamically enable & disable the formatter
    if (clientDynamicRegisterSupport) {
        let enableFormatter = settings && settings.yaml && settings.yaml.format && settings.yaml.format.enable;
        if (enableFormatter) {
            if (!formatterRegistration) {
                formatterRegistration = connection.client.register(vscode_languageserver_1.DocumentFormattingRequest.type, { documentSelector: [{ language: 'yaml' }] });
            }
        }
        else if (formatterRegistration) {
            formatterRegistration.then(r => r.dispose());
            formatterRegistration = null;
        }
    }
});
function getSchemaStoreMatchingSchemas() {
    return request_light_1.xhr({ url: "http://schemastore.org/api/json/catalog.json" }).then(response => {
        let languageSettings = {
            schemas: []
        };
        let schemas = JSON.parse(response.responseText);
        for (let schemaIndex in schemas.schemas) {
            let schema = schemas.schemas[schemaIndex];
            if (schema && schema.fileMatch) {
                for (let fileMatch in schema.fileMatch) {
                    let currFileMatch = schema.fileMatch[fileMatch];
                    if (currFileMatch.indexOf('.yml') !== -1 || currFileMatch.indexOf('.yaml') !== -1) {
                        languageSettings.schemas.push({ uri: schema.url, fileMatch: [currFileMatch] });
                    }
                }
            }
        }
        return languageSettings;
    }, (error) => {
        throw error;
    });
}
connection.onNotification(SchemaAssociationNotification.type, associations => {
    schemaAssociations = associations;
    specificValidatorPaths = [];
    updateConfiguration();
});
function updateConfiguration() {
    let languageSettings = {
        validate: true,
        schemas: [],
        customTags: customTags
    };
    if (schemaAssociations) {
        for (var pattern in schemaAssociations) {
            let association = schemaAssociations[pattern];
            if (Array.isArray(association)) {
                association.forEach(uri => {
                    languageSettings = configureSchemas(uri, [pattern], null, languageSettings);
                });
            }
        }
    }
    if (schemaConfigurationSettings) {
        schemaConfigurationSettings.forEach(schema => {
            let uri = schema.url;
            if (!uri && schema.schema) {
                uri = schema.schema.id;
            }
            if (!uri && schema.fileMatch) {
                uri = 'vscode://schemas/custom/' + encodeURIComponent(schema.fileMatch.join('&'));
            }
            if (uri) {
                if (uri[0] === '.' && workspaceRoot && !hasWorkspaceFolderCapability) {
                    // workspace relative path
                    uri = vscode_uri_1.default.file(path.normalize(path.join(workspaceRoot.fsPath, uri))).toString();
                }
                languageSettings = configureSchemas(uri, schema.fileMatch, schema.schema, languageSettings);
            }
        });
    }
    if (schemaStoreSettings) {
        languageSettings.schemas = languageSettings.schemas.concat(schemaStoreSettings);
    }
    exports.customLanguageService.configure(languageSettings);
    // Revalidate any open text documents
    documents.all().forEach(triggerValidation);
}
function configureSchemas(uri, fileMatch, schema, languageSettings) {
    if (uri.toLowerCase().trim() === "kubernetes") {
        uri = exports.KUBERNETES_SCHEMA_URL;
    }
    if (uri.toLowerCase().trim() === "kedge") {
        uri = exports.KEDGE_SCHEMA_URL;
    }
    if (schema === null) {
        languageSettings.schemas.push({ uri, fileMatch: fileMatch });
    }
    else {
        languageSettings.schemas.push({ uri, fileMatch: fileMatch, schema: schema });
    }
    if (fileMatch.constructor === Array && uri === exports.KUBERNETES_SCHEMA_URL) {
        fileMatch.forEach((url) => {
            specificValidatorPaths.push(url);
        });
    }
    else if (uri === exports.KUBERNETES_SCHEMA_URL) {
        specificValidatorPaths.push(fileMatch);
    }
    return languageSettings;
}
function setKubernetesParserOption(jsonDocuments, option) {
    for (let jsonDoc in jsonDocuments) {
        jsonDocuments[jsonDoc].configureSettings({
            isKubernetes: option
        });
    }
}
function isKubernetes(textDocument) {
    for (let path in specificValidatorPaths) {
        let globPath = specificValidatorPaths[path];
        let fpa = new azure_pipelines_language_service_3.FilePatternAssociation(globPath);
        if (fpa.matchesPattern(textDocument.uri)) {
            return true;
        }
    }
    return false;
}
documents.onDidChangeContent((change) => {
    triggerValidation(change.document);
});
documents.onDidClose(event => {
    cleanPendingValidation(event.document);
    connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
});
let pendingValidationRequests = {};
const validationDelayMs = 200;
function cleanPendingValidation(textDocument) {
    let request = pendingValidationRequests[textDocument.uri];
    if (request) {
        clearTimeout(request);
        delete pendingValidationRequests[textDocument.uri];
    }
}
function triggerValidation(textDocument) {
    cleanPendingValidation(textDocument);
    pendingValidationRequests[textDocument.uri] = setTimeout(() => {
        delete pendingValidationRequests[textDocument.uri];
        validateTextDocument(textDocument);
    }, validationDelayMs);
}
function validateTextDocument(textDocument) {
    if (!textDocument) {
        return;
    }
    if (textDocument.getText().length === 0) {
        connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: [] });
        return;
    }
    let yamlDocument = azure_pipelines_language_service_4.parse(textDocument.getText(), customTags);
    isKubernetes(textDocument) ? setKubernetesParserOption(yamlDocument.documents, true) : setKubernetesParserOption(yamlDocument.documents, false);
    exports.customLanguageService.doValidation(textDocument, yamlDocument).then(function (diagnosticResults) {
        let diagnostics = [];
        for (let diagnosticItem in diagnosticResults) {
            diagnostics.push(diagnosticResults[diagnosticItem]);
        }
        connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: azure_pipelines_language_service_1.removeDuplicatesObj(diagnostics) });
    }, function (error) { });
}
connection.onDidChangeWatchedFiles((change) => {
    // Monitored files have changed in VSCode
    let hasChanges = false;
    change.changes.forEach(c => {
        if (exports.customLanguageService.resetSchema(c.uri)) {
            hasChanges = true;
        }
    });
    if (hasChanges) {
        documents.all().forEach(validateTextDocument);
    }
});
connection.onCompletion(textDocumentPosition => {
    let textDocument = documents.get(textDocumentPosition.textDocument.uri);
    let result = {
        items: [],
        isIncomplete: false
    };
    if (!textDocument) {
        return Promise.resolve(result);
    }
    let completionFix = azure_pipelines_language_service_1.completionHelper(textDocument, textDocumentPosition.position);
    let newText = completionFix.newText;
    let jsonDocument = azure_pipelines_language_service_4.parse(newText);
    isKubernetes(textDocument) ? setKubernetesParserOption(jsonDocument.documents, true) : setKubernetesParserOption(jsonDocument.documents, false);
    return exports.customLanguageService.doComplete(textDocument, textDocumentPosition.position, jsonDocument);
});
function is_EOL(c) {
    return (c === 0x0A /* LF */) || (c === 0x0D /* CR */);
}
connection.onCompletionResolve(completionItem => {
    return exports.customLanguageService.doResolve(completionItem);
});
connection.onHover(textDocumentPositionParams => {
    let document = documents.get(textDocumentPositionParams.textDocument.uri);
    if (!document) {
        return Promise.resolve(void 0);
    }
    let jsonDocument = azure_pipelines_language_service_4.parse(document.getText());
    isKubernetes(document) ? setKubernetesParserOption(jsonDocument.documents, true) : setKubernetesParserOption(jsonDocument.documents, false);
    return exports.customLanguageService.doHover(document, textDocumentPositionParams.position, jsonDocument);
});
connection.onDocumentSymbol(documentSymbolParams => {
    let document = documents.get(documentSymbolParams.textDocument.uri);
    if (!document) {
        return;
    }
    let jsonDocument = azure_pipelines_language_service_4.parse(document.getText());
    return exports.customLanguageService.findDocumentSymbols(document, jsonDocument);
});
connection.onDocumentFormatting(formatParams => {
    let document = documents.get(formatParams.textDocument.uri);
    if (!document) {
        return;
    }
    return exports.customLanguageService.doFormat(document, formatParams.options, customTags);
});
connection.listen();
//# sourceMappingURL=server.js.map